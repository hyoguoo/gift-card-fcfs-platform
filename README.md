# Gift Card FCFS Platform

선착순 기프트 카드 구매 프로젝트인 **Gift Card FCFS Platform**은 **대규모 트래픽 환경**에서 안정적으로 기프트 카드를 구매할 수 있도록 설계되었습니다.  
이 프로젝트는 **MSA를 기반으로 한 고성능 시스템**을 목표로 하고 있으며, Redis 및 Kafka와 같은 고속 처리 및 메시지 큐를 이용하여 주문과 결제 기능을 구현하였습니다.

<br>

## 🚀 프로젝트 목표

1. **대규모 트래픽 지원**: 높은 트래픽 환경에서도 오토스케일링이 용이한 Spring Cloud 기반 MSA 환경을 구축하여 정확하고 효율적인 서비스를 제공
2. **재고 관리 최적화**: Redis를 이용한 실시간 재고 관리와 Kafka를 통한 이벤트 기반 비동기 처리로 재고 상태의 신뢰성을 확보
3. **안정적 트랜잭션 보장**: SAGA 패턴을 통한 트랜잭션 보장 및 각 서비스 간의 유연한 에러 핸들링 체계 구축

<br>

## 🏗 프로젝트 아키텍처

![Architecture Diagram](https://github.com/user-attachments/assets/44693dab-56b6-4a45-8f73-7551342e2fed)

### 🛠 사용 기술 스택

- Java 21
- Spring Boot 3.3.5
- MySQL 8.0.33
- Redis 7.0.11
- Kafka
- Spring Cloud 2023.0.3

<details>
<summary>📌 스택 선정 이유</summary>

- Redis: 실시간 재고 관리 및 활성 사용자 상태 캐싱으로 빠르고 안정적인 데이터 접근 제공 가능
- Kafka: 높은 트래픽을 처리하며 서비스 간 데이터 동기화 및 트랜잭션 관리에 적합
- Spring Cloud: 모든 서비스가 Spring 기반으로 개발되고 있어 기존 기술 스택과의 높은 호환성과 생산성을 제공하여 선택

</details>

### 🧩 주요 서비스

- **API Gateway**
    - 요청 시 토큰 디코딩 및 Redis 조회를 통해 사용자 활성 상태를 효율적으로 검증하여 서비스 응답 시간 최적화
- **User Service**
    - 로그인 또는 로그아웃 시 Redis 캐시에 사용자 활성화 상태를 업데이트하여 최신 정보 유지
- **Gift Card Service**
    - 기프트 카드 생성 / 재고 관리 / 사용 내역 관리
    - Kafka 이벤트 수신을 통해 실시간 재고 업데이트 및 데이터 일관성 유지
- **Order Service**
    - 주문 생성 및 관리, 결제 전 기프트 카드와 사용자 정보 검증
    - `PENDING`, `COMPLETED`, `FAILED` 등 주문 상태의 전환 관리
    - 결제 실패 시 재고 복구 및 주문 취소를 포함한 보상 트랜잭션을 try-catch 기반으로 처리
- **Payment Service**
    - 결제 처리와 외부 결제 API 연동
    - 결제 이벤트 상태(`READY`, `IN_PROGRESS`, `DONE`, `FAIL`) 관리
    - Redis를 통한 재고 데이터 직접 접근 및 관리로 빠른 재고 확인과 데이터 일관성 확보
    - 결제 실패 시 재고 복구 및 주문 상태 취소를 포함한 SAGA 기반 보상 트랜잭션 수행

<br>

## 🔑 핵심 기능

### 📦 1. **실시간 재고 관리 시스템**

![Stock Management Diagram](https://github.com/user-attachments/assets/8f7e6f5a-1e74-49f8-baab-20b2c8f015e6)

- **원자적 재고 감소 및 보상 트랜잭션**: Redis와 Lua Script를 활용해 재고 감소를 원자적으로 처리
- **Kafka 기반 재고 이벤트 전파**: 재고 변동 시 Kafka를 통해 이벤트를 발행하고, gift-card 서비스는 이를 수신하여 DB의 재고 데이터를 Redis 캐시와 동기화

<details>
<summary>📌 Redis + Lua Script vs 분산락</summary>

|         **방식**         | **장점**                                                                             | **단점**                                                                            |
|:----------------------:|:-----------------------------------------------------------------------------------|:----------------------------------------------------------------------------------|
| **Redis + Lua Script** | - 원자적 연산 가능: Lua Script로 재고 감소와 검증을 한 번에 처리<br>- 고성능: 단일 Redis 인스턴스에서 처리되므로 속도가 빠름 | - 단일 실패 지점: Redis가 단일 장애 지점(SPOF)이 될 수 있음<br>- 복잡한 복구: Lua Script 오류 발생 시 디버깅 어려움 |
|        **분산락**         | - 명시적 락 관리 가능: 재고 감소 처리에서 충돌을 최소화                                                  | - 높은 지연 시간: 락 획득과 해제 과정에서 성능 저하 가능<br>- 복잡성 증가: 분산락 구현 및 관리가 복잡                   |

- **최종 선정 이유**
    - 대규모 트래픽 처리와 높은 성능을 위해 Redis + Lua Script를 선택

</details>

<br>

### 🔄 2. **SAGA 패턴을 통한 트랜잭션 관리**

- **Kafka 기반 이벤트 트리거**: 결제 및 재고 감소와 같은 이벤트를 Kafka를 통해 각 서비스로 전파하며, 서비스들은 이벤트에 맞춰 상태를 업데이트하여 최종 트랜잭션 결과를 일관되게 유지
- **보상 트랜잭션 수행**: 결제 실패 시 Order Info 실패 상태로 변경, Redis 재고 복구, 주문 취소와 같은 보상 트랜잭션을 수행하여 트랜잭션의 안정성과 일관성 확보

<details>
<summary>📌 Orchestration vs Choreography</summary>

|      **방식**       | **장점**                                                              | **단점**                                                                  |
|:-----------------:|:--------------------------------------------------------------------|:------------------------------------------------------------------------|
| **Orchestration** | - 중앙 제어: 중앙 서비스가 전체 트랜잭션 흐름을 관리<br>- 디버깅 용이: 트랜잭션 상태를 한 곳에서 모니터링 가능 | - 단일 실패 지점: 오케스트레이터 장애 시 트랜잭션 진행 불가<br>- 복잡성 증가: 오케스트레이터의 로직이 복잡해질 수 있음 |
| **Choreography**  | - 분산 처리: 각 서비스가 독립적으로 이벤트를 처리<br>- 확장성: 서비스 간 결합도가 낮아 유연한 확장이 가능    | - 디버깅 어려움: 트랜잭션 상태 추적이 어려움<br>- 복잡성 증가: 이벤트 흐름을 이해하고 관리하기 어려움           |

- **최종 선정 이유**
    - 현재 서비스 간 직접적으로 SAGA 패턴을 활용하여 Choreography 방식을 채택
    - 비록 디버깅과 상태 추적이 어려울 수 있지만, 각 서비스 간 이벤트 흐름과 상태 전파를 명확히 설계하여 보완

</details>

<br>

### 🔗 3. **데이터베이스 간 데이터 동기화**

![Data Synchronization Diagram](https://github.com/user-attachments/assets/d3bc8233-fe2f-4fdf-b2e1-840aa3cc9d05)

- **Kafka 기반 실시간 데이터 동기화**: Kafka 이벤트 메시징 시스템을 사용하여 공통 데이터가 필요한 여러 서비스 간에 실시간 데이터 동기화 구현
- **변경 이벤트 기반 업데이트**: 각 서비스에서 데이터베이스 상태가 변경될 때마다 이벤트를 발행하며, 이를 통해 다른 서비스들이 필요한 업데이트를 수신해 데이터 일관성 유지
- **기프트 카드 구매 정보 동기화 예시**: gift-card 서비스에서 사용자 구매 정보를 이벤트로 발행하고, user 서비스에서 이를 수신하여 사용자 관련 정보를 업데이트함으로써 중복 데이터의 무결성 확보

<details>
<summary>📌CDC(Change Data Capture) vs Kafka 기반 이벤트</summary>

|      **방식**      | **장점**                                                                     | **단점**                                                                            |
|:----------------:|:---------------------------------------------------------------------------|:----------------------------------------------------------------------------------|
|     **CDC**      | - 실시간 동기화 가능: DB 로그 기반으로 데이터 변경 사항 감지<br>- 변경 최소화: 기존 DB 구조에 직접적인 변경 필요 없음 | - 초기 설정 복잡: CDC 도구 설치 및 설정이 복잡할 수 있음<br>- 성능 이슈: DB 변경 로그를 지속적으로 모니터링하므로 DB 부하 증가 |
| **Kafka 기반 이벤트** | - 유연성: 이벤트를 자유롭게 설계 가능하며, 특정 서비스에 최적화 가능<br>- 확장성: 대규모 트래픽을 안정적으로 처리 가능    | - 이벤트 손실 가능성: 구성 관리 실패 시 데이터 손실 위험<br>- 초기 구현 비용: 이벤트 설계 및 처리 로직 구축 필요            |

- **최종 선정 이유**
    - Kafka의 확장성과 유연성 덕분에 대규모 트래픽을 처리할 수 있으며, 실시간 데이터 동기화에도 적합하다 판단하여 Kafka 기반 이벤트 방식을 선택

</details>

<br>

### 🔐 4. **API Gateway 기반 사용자 인증**

![API Gateway Diagram](https://github.com/user-attachments/assets/94014662-421e-4541-98b1-fcec9f4775c3)

- **White List URL 설정**: 인증이 필요하지 않은 경로를 사전에 정의하여 불필요한 인증 절차를 줄이고 서비스 성능 최적화
- **사용자 상태 확인**: 로그인 또는 로그아웃 시 User Service가 Redis 캐시에 사용자 활성 상태를 실시간으로 업데이트하여 최신 정보 유지
- **토큰 디코딩과 Redis 조회를 통한 인증 처리**: API Gateway는 각 요청에서 JWT 토큰을 디코딩하여 사용자 ID를 추출하고, Redis에 캐싱된 활성 사용자 정보를 조회하여 로그인 상태를 확인

<details>
<summary>📌 JWT 디코딩 + Redis 조회 방식 vs User Service 통해 조회</summary>

|         **방식**         | **장점**                                                                                                                                               | **단점**                                                                                        |
|:----------------------:|:-----------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------|
| **JWT 디코딩 + Redis 조회** | - 빠른 인증 처리 가능: Redis는 메모리 기반이라 조회 속도가 빠름<br>- User Service 부하 감소: 모든 요청이 User Service를 경유하지 않음<br>- 실시간 상태 반영 가능: Redis 캐시를 업데이트하여 로그아웃이나 비활성화 상태 반영 | - Redis 캐시의 추가 관리 필요: 캐시 만료나 동기화 문제 발생 가능<br>- 데이터 정합성 이슈 가능: Redis와 DB 간 동기화 실패 시 데이터 불일치 가능 |
| **User Service 직접 조회** | - 데이터 정확성 보장: 항상 최신 데이터 조회 가능<br>- 캐시 동기화 문제 없음: Redis를 사용하지 않으므로 관리 필요 없음                                                                           | - 높은 부하: 모든 요청이 User Service를 경유하여 성능 저하 가능<br>- 확장성 부족: 트래픽 증가 시 병목 현상 발생 가능                 |

- **최종 선정 이유**
    - Redis 기반 인증 처리가 더 높은 성능을 제공하며, 불필요한 리소스 소모를 줄일 수 있어 대규모 트래픽 환경에 적합하다고 판단

</details>

<br>

### 🛡 5. **Feign Client 및 Error Decoder를 통한 예외 처리 세분화**

- **Feign Client를 통한 서비스 간 통신 표준화**: Feign Client를 사용해 내부 서비스 간 통신을 표준화된 인터페이스로 구현하여 서비스 간의 상호작용을 간결하고 일관되게 유지
- **Error Decoder를 통한 예외 처리 세분화**: 서비스 호출 시 발생하는 오류를 Error Decoder로 각 도메인에 맞는 커스텀 예외로 변환

<br>

## 💳 메인 기능 플로우 - 주문 및 결제

### 1. 주문 생성 단계

![Event Flow Diagram](https://github.com/user-attachments/assets/554ca29f-efb3-4719-90e2-cd65d8459814)

1. **Gift Card 조회**: gift-card 서비스에서의 동기적 gift card 정보 조회
2. **주문 정보 저장**: `PENDING` 상태로 주문 정보 저장
3. **결제 요청**: payment 서비스에 동기적 요청 전송 및 `READY` 상태로 결제 이벤트 저장

### 2. 주문 승인 요청 단계

![Event Flow Diagram](https://github.com/user-attachments/assets/d73d7203-27df-4a16-b547-e716faf0bb5b)

1. **결제 이벤트 조회**: 저장된 payment event 정보 불러오기
2. **결제 상태 갱신**: 결제 이벤트의 `IN_PROGRESS` 상태로의 변경
3. **재고 감소 처리**:
    - **Redis 재고 감소**: 원자적 Redis 재고 확인 및 차감
    - **재고 감소 성공 시**:
        - **메시지 발행**: gift-card 서비스로의 메시지 발행 및 DB 재고 차감
    - **재고 감소 실패 시**:
        - **결제 실패 처리**: `FAIL` 상태로의 payment event 변경 및 주문 실패 메시지 발행 및 order 서비스에서 `FAILED` 상태로의 업데이트
4. **토스 결제 정보 조회 및 교차 검증**:
    - 검증 실패 시:
        - **재고 복구**: Redis 재고 복구 및 gift-card 서비스로의 메시지 발행을 통한 DB 재고 증가
5. **토스 결제 승인 요청**:
    - **재시도 가능 실패 시**: `UNKNOWN` 상태로의 payment event 변경
    - **재시도 불가능 실패 시**:
        - **재고 복구 및 결제 실패 처리**: Redis 재고 복구 및 gift-card 서비스로의 메시지 발행을 통한 DB 재고 복구, `FAIL` 상태로의 payment event 변경 및 주문 실패
          메시지 발행을 통한 order 서비스의 `FAILED` 상태로의 업데이트
6. **결제 승인 성공 시**:
    - **결제 완료 처리**: `DONE` 상태로의 payment event 변경 및 주문 성공 메시지 발행을 통한 order 서비스의 `COMPLETED` 상태로의 업데이트
    - **기프트 카드 구매 데이터 동기화**:
        - gift-card 서비스로의 메시지 수신을 통한 `gift_card_user` 테이블 데이터 저장 및 user 서비스로의 메시지 발행을 통한 `user_gift_card` 데이터 동기화

<br>
